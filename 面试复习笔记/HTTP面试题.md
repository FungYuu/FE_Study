## HTTP报文结构

- HTTP报文由**报文首部**和**报文主体**构成，中间由一个**空行分隔**。

  报文首部是**处理请求或响应的内容及属性，可以传递额外的信息。**

  报文主体主要**包含被发送的信息。**

  **报文首部包含 请求行 和 请求头部**

### 请求报文

一个HTTP请求报文由**请求行，请求头部，空行和请求数据**4部分组成。

- **请求行**：，方法 + URI + HTTP版本 组成
- **请求头部**：首部字段名和字段值构成，中间用 : 分隔。首部字段格式： 首部字段名:字段值
- **请求数据**： post，put等请求携带的数据

![图片说明](https://uploadfiles.nowcoder.com/images/20210407/1449535_1617801903832/278526F9CD532C9C14FBF3ADB9A2A930)



### 响应报文

HTTP响应报文由**状态行、响应头部、空行和响应体**4部分组成

- **状态行**：HTTP版本 + 状态码 + 状态码的原因短语
- **响应头部**：响应部首组成
- **响应体**：服务器响应的数据

![图片说明](https://uploadfiles.nowcoder.com/images/20210407/1449535_1617801939424/FB5C81ED3A220004B71069645F112867)



## HTTP的部首有哪些？

1. **通用首部字段**：请求报文和响应报文两方都会使用的首部

   Cache-Control 控制缓存 

   Date 创建报文的日期

   Connection 连接管理、逐条首部 

   Transfor-Encoding 报文主体的传输编码格式 

   

2. **请求首部字段**:**客户端**向**服务器**发送请求的报文时使用的首部

   Accept 客户端或者代理能够处理的媒体类型 

   If-Match 比较实体标记（ETage） 

   If-None-Match 比较实体标记（ETage）与 If-Match相反 

   If-Modified-Since 比较资源更新时间（Last-Modified）

   Range 实体的字节范围请求 

   Host 请求资源所在服务器 

   

3. **响应首部字段**:从**服务器**向**客户端**响应时使用的字段

   Location 令客户端重定向的URI 

   ETag 能够表示资源唯一资源的字符串 

   Server 服务器的信息 

   

4. **实体首部字段**:针对**请求报文**和**响应报文**的实体部分使用首部

   Allow 资源可支持http请求的方法 

   Last-Modified 资源最后的修改资源 

   Expires 实体主体的过期资源 

   

## HTTP方法

- HTTP 1.0 定义了三种请求方法：GET、POST 和 HEAD 方法
- HTTP 1.1 新增了六种方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法

|  方法   |                        描述                        |
| :-----: | :------------------------------------------------: |
|   GET   |              用于从服务器**获取数据**              |
|  POST   | 向URL指定的资源**提交数据**，数据被包含在请求体中  |
|   PUT   |                  向服务器修改数据                  |
|  HEAD   |          请求页面的首部，获取资源的元信息          |
| DELETE  |                   **删除数据**。                   |
| CONNECT |           建立连接隧道，用于代理服务器；           |
| OPTIONS |       列出可对资源实行的请求方法，常用于跨域       |
|  TRACE  |     回显服务器收到的请求，主要用于测试或诊断。     |
|  PATCH  | 是对 PUT 方法的补充，用来对已知资源进行局部更新 。 |

为了方便记忆

- GET：获取资源，查询服务器资源。查
- POST：传输数据，向服务器提交数据，对服务器数据进行更新。增
- PUT：上传文件，向服务器修改数据，可以看作。改
- DELETE：删除文件。



### GET与POST方法的区别：

1. GET 从服务器上获取数据，POST是向服务器传送数据

2. GET 请求的数据一般追加在 URL 的末尾，POST请求的数据在 http 请求体中

   GET比POST更不安全，因为参数直接暴露在URL上

3. GET请求传输的数据有长度限制，一般为 2048 字符，POST请求传输的数据没有大小限制

4. GET只允许 ASCII 字符，而POST无限制

5.  刷新、后退等浏览器操作GET请求是无害的，POST可能重复提交



### PUT和POST都是给服务器发送新增资源，有什么区别？

PUT 和POST方法的**区别**,

- PUT方法是幂等的：连续调用一次或者多次的效果相同（无副作用），

  POST方法是非幂等的。

- 通常情况下，PUT的URI指向是**具体单一资源**，而POST可以指向**资源集合**。



### 常见的状态码：

| 状态码 |                            描述                            |
| :----: | :--------------------------------------------------------: |
|  200   |                          请求成功                          |
|  204   |                请求处理成功，但没有资源返回                |
|  301   |   永久性重定向。该状态码表示请求的资源已被分配了新的URI    |
|  302   |                        临时性重定向                        |
|  304   | 资源未修改，服务器不会返回任何资源，告诉浏览器使用本地缓存 |
|  400   |              服务端无法理解，客户端请求的语法              |
|  401   |                未授权，当前请求需要用户验证                |
|  403   |                       服务器拒绝请求                       |
|  404   |                         资源未找到                         |
|  500   |                       服务器内部错误                       |



### HTTP状态码304是多好还是少好

状态码304是对客户端**有缓存情况下**服务端的一种响应。

搜索引擎蜘蛛会更加青睐内容源更新频繁的网站。



## 与缓存相关的HTTP请求头有哪些

强缓存：

- Expires
- Cache-Control

协商缓存：

- Etag、If-None-Match
- Last-Modified、If-Modified-Since



## 检查浏览器是否有缓存

1. 通过`Cache-Control`和`Expires`来检查是否命中强缓存，命中则直接取本地磁盘的html（状态码为200 from disk(or memory)  cache，内存or磁盘）；
2. 如果没有命中强缓存，则会向服务器发起请求（先进行下一步的TCP连接），服务器通过`Etag`和`Last-Modify`来与服务器确认返回的响应是否被更改（协商缓存），若无更改则返回状态码（304 Not Modified）,浏览器取本地缓存；
3. 若强缓存和协商缓存都没有命中则返回请求结果。



### 强缓存

- 首先是检查强缓存，这个阶段`不需要`发送HTTP请求

  当缓存数据库中有客户端需要的数据，客户端直接将数据从其中拿出来使用（如果数据未失效），当缓存服务器没有需要的数据时，客户端才会向服务端请求。


- Exprires： 的值为服务端返回的数据到期时间。当再次请求时的请求时间小于返回的此时间，则直接使用缓存数据。

  

- 现在大多数使用**Cache-Control**替代。

  `Cache-Control`和`Expires`本质的不同在于它并没有采用`具体的过期时间点`这个方式，而是采用过期时长来控制缓存，对应的字段是**max-age**。

### 协商缓存

- 强缓存失效之后，浏览器在请求头中携带相应的`缓存tag`来向服务器发请求，由服务器根据这个tag，来决定是否使用缓存，这就是**协商缓存**。

  这样的缓存tag分为两种: **Last-Modified** 和 **ETag**。

  

- #### Last-Modified

  即**最后修改时间**。在浏览器第一次给服务器发送请求后，服务器会在响应头中加上这个字段。

- 浏览器接收到后，如果**再次请求**，会在请求头中携带`If-Modified-Since`字段，这个字段的值也就是服务器传来的最后修改时间。

- 服务器拿到请求头中的`If-Modified-Since`的字段后，其实会和这个服务器中`该资源的最后修改时间`对比:

  - 如果请求头中的这个值小于最后修改时间，说明是时候更新了。返回新的资源，跟常规的HTTP请求响应的流程一样。
  - 否则返回304，告诉浏览器直接用缓存。

  

- #### ETag

  `ETag` 是服务器根据当前文件的内容，给文件**生成的唯一标识**，只要里面的内容有改动，这个值就会变。服务器通过`响应头`把这个值给浏览器。

- 浏览器接收到`ETag`的值，会在下次请求时，将这个值作为**If-None-Match**这个字段的内容，并放到请求头中，然后发给服务器。

- 服务器接收到**If-None-Match**后，会跟服务器上该资源的**ETag**进行比对:

  - 如果两者不一样，说明要更新了。返回新的资源，跟常规的HTTP请求响应的流程一样。
  - 否则返回304，告诉浏览器直接用缓存。

  

  #### 两者对比

  1. 在`精准度`上，`ETag`优于`Last-Modified`。

     优于 ETag 是按照内容给资源上标识，因此能准确感知资源的变化。而 Last-Modified 就不一样了，它在一些特殊的情况并不能准确感知资源变化，主要有两种情况:

  - 编辑了资源文件，但是文件内容并没有更改，这样也会造成缓存失效。
  - Last-Modified 能够感知的单位时间是秒，如果文件在 1 秒内改变了多次，那么这时候的 Last-Modified 并没有体现出修改了。

  1. 在性能上，`Last-Modified`优于`ETag`，

     `Last-Modified`仅仅只是记录一个时间点，而 `Etag`需要根据文件的具体内容生成哈希值。



##  对浏览器的缓存机制来做个简要的总结:

首先通过 `Cache-Control` 验证强缓存是否可用

- 如果强缓存可用，直接使用

- 否则进入协商缓存，即发送 HTTP 请求，服务器通过请求头中的

  If-Modified-Since或者If-None-Match字段检查资源是否更新

  - 若资源更新，返回资源和200状态码
  - 否则，返回304，告诉浏览器直接从缓存获取资源



## HTTP是什么？优缺点

**HTTP是超文本传输协议**，是一个简单的**请求-响应协议**

它指定了**客户端可能发送给服务器什么样的消息以及得到什么样的响应**。

**优点：**

- 灵活可扩展，除了规定空格分隔单词，换行分隔字段以外，其他都没有限制，不仅仅可以传输文本，还可以传输图片、视频等任意资源
- 可靠传输，基于 TCP/IP 所以继承了这一特性
- 请求-应答，有来有回
- 无状态，每次 HTTP 请求都是独立的，无关的、默认不需要保存上下文信息

**缺点：**

- 明文传输不安全
- 复用一个 TCP 链接，会发生对头拥塞
- 无状态在长连接场景中，需要保存大量上下文，以避免传输大量重复的信息



## HTTPS是什么？优缺点

**HTTPS是超文本传输安全协议**，是一种安全通信的传输协议。

HTTPS经**由HTTP进行通信，但利用 SSL/TSL 来进行加密数据包**。

HTTPS 提供网站服务器的身份认证，保护数据交换的隐私与完整性。

**优点**

- HTTPS协议在传输数据过程中，使用密钥对传输的数据进行加密，安全性较高。
- HTTPS协议可以对用户和服务器进行认证，确保了数据传送的完整性和准确性。



**缺点**

- HTTPS协议握手阶段延时较高： 由于在进行HTTP会话前，还需要进行SSL握手，所以HTTPS协议握手阶段延时会适当增加。

- HTTPS协议部署成本高： 

  首先，HTTPS协议需要购买CA证书，通过证书来验证自身的安全性；

  其次，HTTPS属于加密传输协议，需要进行加密、解密的计算与操作，会占用一定数量的CPU资源，

  因此，需要的服务器配置、数目相对较高。



### HTTP和HTTPS哪一层的协议？

应用层



## HTTP 与 HTTPS 的区别

1. HTTP使用明文传输，安全性比较差；

   HTTPS数据传输过程是加密的，安全性比较好。

2. 使用 HTTPS 一般需要到 CA 申请**证书**

3. HTTP端口是80；

   HTTPS端口是443

4. HTTP页面的响应比HTTPS快，HTTPS除了TCP的三个包，还要加上SSL握手的9个包。

5. HTTPS更消耗服务器资源，HTTPS是在HTTP协议上加上SSL/TSL

   **SSL 的位置**
   应用层和传输层中间

   **SSL 三个功能**
   1. SSL服务器鉴别：允许用户证实服务器的身份
   2.加密的SSL会话：客户和服务器交互的所有数据都在发送方加密。
   3. SSL客户鉴别：允许服务器证实用户的身份

- SSL，即安全套接层协议，是网络通信提供安全及数据完整性的一种安全协议。
- TLS，安全传输层协议，它是SSL 3.0的后续版本。



## HTTPS具体流程

![Https工作流程](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cb9a2a86936a46ceaadb5d46878659c8~tplv-k3u1fbpfcp-watermark.awebp)

1. 用户在浏览器里输入一个HTTPS网址，然后连接到server的443端口。
2. 服务器必须要有一套数字证书，可以自己制作，也可以向组织申请，区别就是自己颁发的证书需要客户端验证通过。这套证书其实就是一对公钥和私钥。
3. 服务器将自己的数字证书（含有公钥）发送给客户端。
4. 客户端收到服务器端的数字证书之后，会对其进行检查，如果不通过，则弹出警告框。如果证书没问题，则生成一个密钥（对称加密），用证书的公钥对它加密。
5. 客户端会发起HTTPS中的第二个HTTP请求，将加密之后的客户端密钥发送给服务器。
6. 服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后得到客户端密钥，然后用客户端密钥对返回数据进行对称加密，这样数据就变成了密文。
7. 服务器将加密后的密文返回给客户端。
8. 客户端收到服务器发返回的密文，用自己的密钥（客户端密钥）对其进行对称解密，得到服务器返回的数据。



## HTTP 1.0 和 HTTP 1.1 区别

- **连接方面**，

  HTTP/1.0中默认使用**短连接**，也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接

  从HTTP/1.1起，默认使用**长连接**，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码`Connection:keep-alive`

  keep-alive不会永久保持连接

- **资源请求方面**，在 http 1.0 中，客户端只是需要某个对象的一部分，而**服务器却将整个对象送过来了**，并且不支持断点续传功能，

  HTTP 1.1 中**引入了 Range 头部字段**，**允许只请求资源的某个部分**，即返回状态码是 206

- **缓存处理**，在 HTTP 1.0 中主要使用 **Expires**头部字段**来作为缓存判断**的标准
  在 HTTP 1.1 中增加了 Cache-Control、Etag、If-None-Match、If-Match 等头部字段来提供可选的更多的缓存策略

- **Host头处理**：http 1.1 中**新增了 host 字段**，用来指定服务器的域名。http 1.0 中认为每台服务器都绑定一个唯一的 IP 地址

- **请求方法**：http 1.1 相对于 http 1.0 还新增了很多**请求方法**，如 PUT、DELETE、CONNECT、OPTIONS 等。



## HTTP 1.1 和 HTTP 2.0 的区别

- **服务器推送：** HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送

- **多路复用：** HTTP/2 实现了多路复用，HTTP/2 仍然复用 TCP 连接 

  多路复用：一个信道同时传输多路信号

- **头信息压缩**：HTTP 1.1的头部（header）带有大量信息，而且每次都要重复发送；HTTP 2.0使用**encoder**来减少需要传输的header大小，通讯双方各自cache一份header fields表




## 什么是无状态协议，HTTP 是无状态协议吗，怎么解决

**无状态协议:**  浏览器对于事务的处理没有记忆能力

**有状态：**

- A：今天吃啥子？
- B：罗非鱼！
- A：味道怎么样呀？
- B：还不错，好香。

**无状态：**

- A：今天吃啥子？
- B：罗非鱼！
- A：味道怎么样呀？
- B：？啊？啥？什么鬼？什么味道怎么样？

**加下cookie这玩意**：

- A：今天吃啥子？
- B：罗非鱼
- A：你今天吃的罗非鱼味道怎么样呀？
- B：还不错，好香。





- HTTP 就是一种无状态的协议，他对用户的操作没有记忆能力。

  可能大多数用户不相信，他可能觉得每次输入用户名和密码登陆一个网站后，下次登陆就不再重新输入用户名和密码了。

  这其实不是 HTTP 做的事情，起作用的是一个叫做 `小甜饼(Cookie)` 的机制。它能够让浏览器具有`记忆`能力。



## 解释一下HTTP长连接和短连接？

- **在HTTP/1.0中，默认使用的是短连接**。

  浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接

  

- 从 **HTTP/1.1起，默认使用长连接**，用以保持连接特性。使用长连接的HTTP协议，会在响应头有加入这行代码：`Connection:keep-alive`

  在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的 TCP连接不会关闭，



### 使用长连接在什么时候会超时？

- 可以设置 keep-alive timeout

  当 TCP链接闲置超过这个时间就会关闭，也可以在HTTP的header里面设置超时时间



## HTTP的keep-alive是干什么的？

- 在早期的HTTP/1.0中，每次http请求都要创建一个连接，而创建连接的过程需要**消耗资源和时间**

  在http请求头中加入Connection: keep-alive来告诉对方这个**请求响应完成后不要关闭，下一次咱们还用这个请求继续交流。**

  协议规定HTTP/1.0如果想要保持长连接，需要在请求头中加上Connection: keep-alive。

keep-alive的优点：

- 较少的CPU和内存的使用（由于同时打开的连接的减少了）
- 允许请求和应答的HTTP管线化
- 降低拥塞控制 （TCP连接减少了）
- 减少了后续请求的延迟（无需再进行握手）
- 报告错误无需关闭TCP连



### HTTP建立持久连接的意义

- 在 HTTP 1.0 中每发送一次请求都要重新建立 TCP 连接并且关闭连接。这样做是很耗费时间的。

  而在HTTP 1.1 中默认开启长连接，一次TCP连接可以发送多个HTTP请求，避免了重复建立释放连接的开销，加速了数据的传输，节省了时间和带宽。



## 对称加密和非对称加密

### **对称加密**

- **对称加密**的方法是，双方使用同一个秘钥对数据进行加密和解密。

  对称加密的**存在一个问题**，就是怎么**保证秘钥传输的安全性**，还是会通过网络传输的，一旦秘钥被其他人获取到，那么整个加密过程就毫无作用了。



### 非对称加密

- **非对称加密**的方法是，我们拥有两个秘钥，一个是公钥，一个是私钥。

  公钥是公开的，私钥是保密的。

  用私钥加密的数据，只有对应的公钥才能解密，用公钥加密的数据，只有对应的私钥才能解密。

- 非对称加密有一个**缺点就是加密的过程很慢**，因此如果每次通信都使用非对称加密的方式的话，反而会造成等待时间过长的问题。



## **HTTPS**是如何保证安全的？

1. 结合两种加密方式，将对称加密的密钥使用非对称加密的公钥进行加密，然后发送出去，接收方使用私钥进行解密得到对称加密的密钥，然后双方可以使用对称加密来进行沟通。
2. 此时又带来⼀个问题，中间人问题： 如果此时在客户端和服务器之间存在⼀个中间人,这个中间人只需要把原本双方通信互发的公钥,换成自己的公钥,这样中间人就可以轻松解密通信双方所发送的所有数据。
3. 所以这个时候需要⼀个安全的第三方颁发证书（CA），证明身份的身份，防止被中间人攻击。 证书中包括：签发者、证书用途、使用者公钥、使用者私钥、使用者的HASH算法、证书到期时间等。
4. 但是问题来了，如果中间人篡改了证书，那么身份证明是不是就无效了？这个证明就白买了，这个时候需要⼀个新的技术，数字签名。
5. 数字签名就是用CA自带的HASH算法对证书的内容进行HASH得到⼀个摘要，再用CA的私钥加密，最终组成数字签名。当别⼈把他的证书发过来的时候,我再⽤同样的Hash算法,再次生成消息摘要，然后用CA的公钥对数字签名解密,得到CA创建的消息摘要,两者⼀比,就知道中间有没有被人篡改了。这个时候就能最大程度保证通信的安全了




## Cookie

**Cookie**: 储存在用户本地终端上的数据



### Cookie 相关首部字段

1. **expires**

   指定浏览器可发送Cookie的有效期。当省略 expires 属性的时候，其有效期仅限于维持浏览器会话期间。

2. **path**

   默认为 /，就是根目录。**子路径页面能够访问父路径页面的 Cookie**。兄弟路径页面之间的 Cookie 不能互相访问

3. **domain**

   可以访问该 Cookie 的域名。

4. **maxAge** 表示cookie失效时间

5. **same-site** 规定浏览器不能在跨域请求中携带 Cookie，减少CSRF攻击

6. **secure** 表示cookie是否使用安全协议传输如HTTPS、SSL，默认不使用



















































